Цвета представлены в формате int. Поэтому для получения int,
который может содержать значения ARGB, требуются некоторые хитрые вещи.

Стандарт цветового целого числа

Мы сдвигаем биты, чтобы использовать формат TRGB.
Чтобы определить цвет, мы инициализируем его следующим образом: 0xTTRRGGBB,
где каждый символ представляет следующее:

буква      описание
T           прозрачность
R           красный компонент
G           зеленый компонент
B           синий компонент

Цвета RGB могут быть инициализированы, как указано выше, несколько примеров будут:

Цвет           TRGB  представления
красный             0x00FF0000
зеленый             0x0000FF00
синий               0x000000FF


Кодирование и декодирование цветов

Мы можем использовать два метода для кодирования и декодирования цветов:

 - Сдвиг битов
 - Сhar/int преоразование

 Сдвиг битов

Поскольку каждый байт содержит 2 ^ 8 = 256 значений (1 байт = 8 бит),
а значения RGB варьируются от 0 до 255, мы можем идеально подогнать целое число
(так как int равно 4 байтам).
Для того, чтобы установить значения программно, мы используем сдвиг битов.
Давайте создадим функцию, которая делает именно это для нас, не так ли?

int	create_trgb(int t, int r, int g, int b)
{
	return (t << 24 | r << 16 | g << 8 | b);
}

Поскольку целые числа хранятся справа налево,
нам нужно сдвинуть каждое значение на соответствующее количество битов назад.
Мы также можем сделать прямо противоположное и извлечь целочисленные значения
из закодированного целого числа TRGB.

int	get_t(int trgb)
{
	return ((trgb >> 24) & 0xFF);
}

int	get_r(int trgb)
{
	return ((trgb >> 16) & 0xFF);
}

int	get_g(int trgb)
{
	return ((trgb >> 8) & 0xFF);
}

int	get_b(int trgb)
{
	return (trgb & 0xFF);
}

Сhar/int преоразование

Поскольку каждый байт содержит 2 ^ 8 = 256 значений (1 байт = 8 бит),
а значения RGB варьируются от 0 до 255, мы можем идеально подогнать символ
без знака для каждого параметра TRGB {T, R, G, B} (символ равен 1 байту)
и подогнать значение int для значения TRGB (int равно 4 байтам).
Для того, чтобы установить значения программно, мы используем преобразование типов.

int	create_trgb(unsigned char t, unsigned char r, unsigned char g, unsigned char b)
{
	return (*(int *)(unsigned char [4]){b, g, r, t});
}

unsigned char	get_t(int trgb)
{
	return (((unsigned char *)&trgb)[3]);
}

unsigned char	get_r(int trgb)
{
	return (((unsigned char *)&trgb)[2]);
}

unsigned char	get_g(int trgb)
{
	return (((unsigned char *)&trgb)[1]);
}

unsigned char	get_b(int trgb)
{
	return (((unsigned char *)&trgb)[0]);
}

Чтобы понять преобразование,
вы можете обратиться к таблице ниже, где 0x0FAE1 - адрес переменной int trgb.

Address 	    char 	                int
0x0FAE1 	unsigned char b 	      int trgb
0x0FAE2 	unsigned char g 	    [allocated]
0x0FAE3 	unsigned char r 	    [allocated]
0x0FAE4 	unsigned char t 	    [allocated]

Проверьте свои навыки!

Теперь, когда вы понимаете основы того, как можно инициализировать цвета,
устройтесь поудобнее и попробуйте создать следующие функции манипулирования цветом:

 add_shade - это функция, которая принимает double (расстояние) и int (цвет)
 в качестве аргументов, 0 не добавит затенения к цвету,
 в то время как 1 сделает цвет полностью темным. 0,5 затемнит его наполовину и .25 на четверть.
 Вы поняли, в чем дело.
 get_opposite - это функция, которая принимает значение int (цвет)
 в качестве аргумента и соответствующим образом инвертирует цвет.
